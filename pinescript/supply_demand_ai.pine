//@version=5
indicator('QuoTrading AI Signal', 'QT AI', overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500)
//---------------------------------------------------------------------------------------------------------------------}
//CONSTANTS & STRINGS & INPUTS
//---------------------------------------------------------------------------------------------------------------------{
BULLISH_LEG                     = 1
BEARISH_LEG                     = 0

BULLISH                         = +1
BEARISH                         = -1

// ===== MODERN COLOR PALETTE =====
DEMAND_PRIMARY                  = #00BCD4  // Teal/Cyan
DEMAND_SECONDARY                = #26A69A  // Darker Teal
SUPPLY_PRIMARY                  = #FF6B6B  // Coral
SUPPLY_SECONDARY                = #E91E63  // Magenta
ACCENT_GOLD                     = #FFD700  // Gold accent
PANEL_BG                        = #0d1117  // Dark panel background
PANEL_BORDER                    = #30363d  // Panel border

// Legacy colors (for compatibility)
GREEN                           = DEMAND_PRIMARY
RED                             = SUPPLY_PRIMARY
BLUE                            = #2157f3
GRAY                            = #878b94
MONO_BULLISH                    = #b2b5be
MONO_BEARISH                    = #5d606b

HISTORICAL                      = 'Historical'
PRESENT                         = 'Present'

COLORED                         = 'Colored'
MONOCHROME                      = 'Monochrome'

ALL                             = 'All'
BOS                             = 'BOS'
CHOCH                           = 'CHoCH'

TINY                            = size.tiny
SMALL                           = size.small
NORMAL                          = size.normal

ATR                             = 'Atr'
RANGE                           = 'Cumulative Mean Range'

CLOSE                           = 'Close'
HIGHLOW                         = 'High/Low'

SOLID                           = '‚éØ‚éØ‚éØ'
DASHED                          = '----'
DOTTED                          = '¬∑¬∑¬∑¬∑'

// ===== SETTINGS GROUPS =====
SMART_GROUP                     = '‚öôÔ∏è General'
INTERNAL_GROUP                  = 'Internal Structure'
SWING_GROUP                     = 'Swing Structure'
BLOCKS_GROUP                    = 'üìä Supply & Demand Zones'
EQUAL_GROUP                     = 'EQH/EQL'
GAPS_GROUP                      = 'üìà Fair Value Gaps'
LEVELS_GROUP                    = 'üìÖ Daily/Weekly/Monthly Levels'
ZONES_GROUP                     = 'üéØ Premium & Discount'


modeTooltip                     = 'Allows to display historical Structure or only the recent ones'
styleTooltip                    = 'Indicator color theme'
showTrendTooltip                = 'Display additional candles with a color reflecting the current trend detected by structure'
showInternalsTooltip            = 'Display internal market structure'
internalFilterConfluenceTooltip = 'Filter non significant internal structure breakouts'
showStructureTooltip            = 'Display swing market Structure'
showSwingsTooltip               = 'Display swing point as labels on the chart'
showHighLowSwingsTooltip        = 'Highlight most recent strong and weak high/low points on the chart'
showInternalOrderBlocksTooltip  = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
showSwingOrderBlocksTooltip     = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
orderBlockFilterTooltip         = 'Method used to filter out volatile order blocks \n\nIt is recommended to use the cumulative mean range method when a low amount of data is available'
orderBlockMitigationTooltip     = 'Select what values to use for order block mitigation'
showEqualHighsLowsTooltip       = 'Display equal highs and equal lows on the chart'
equalHighsLowsLengthTooltip     = 'Number of bars used to confirm equal highs and equal lows'
equalHighsLowsThresholdTooltip  = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
showFairValueGapsTooltip        = 'Display fair values gaps on the chart'
fairValueGapsThresholdTooltip   = 'Filter out non significant fair value gaps'
fairValueGapsTimeframeTooltip   = 'Fair value gaps timeframe'
fairValueGapsExtendTooltip      = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
showPremiumDiscountZonesTooltip = 'Display premium, discount, and equilibrium zones on chart'

// =====================================================================================================================
// SETTINGS - Organized by importance
// =====================================================================================================================

// ===== 1. SUPPLY & DEMAND ZONES (Main Feature) =====
showInternalOrderBlocksInput    = input(        true,       'Internal Zones' ,          group = BLOCKS_GROUP,   tooltip = showInternalOrderBlocksTooltip,   inline = 'iob')
internalOrderBlocksSizeInput    = input.int(    10,         '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 50,                    inline = 'iob')
showSwingOrderBlocksInput       = input(        true,       'Swing Zones',              group = BLOCKS_GROUP,   tooltip = showSwingOrderBlocksTooltip,      inline = 'ob')
swingOrderBlocksSizeInput       = input.int(    10,         '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 50,                    inline = 'ob') 
orderBlockFilterInput           = input.string( 'Atr',      'Zone Filter',              group = BLOCKS_GROUP,   tooltip = orderBlockFilterTooltip,          options = [ATR, RANGE])
orderBlockMitigationInput       = input.string( HIGHLOW,    'Mitigation Type',          group = BLOCKS_GROUP,   tooltip = orderBlockMitigationTooltip,      options = [CLOSE,HIGHLOW])
swingBullishOrderBlockColor     = input.color(color.new(#00BCD4, 70), 'Demand Color',           group = BLOCKS_GROUP)
swingBearishOrderBlockColor     = input.color(color.new(#FF6B6B, 70), 'Supply Color',           group = BLOCKS_GROUP)
internalBullishOrderBlockColor  = input.color(color.new(#26A69A, 75), 'Internal Demand',        group = BLOCKS_GROUP)
internalBearishOrderBlockColor  = input.color(color.new(#E91E63, 75), 'Internal Supply',        group = BLOCKS_GROUP)

// ===== 2. HIGH/LOW OF DAY =====
HODLOD_GROUP                    = 'üìç High/Low of Day'
showHodLodInput                 = input(        true,       'Show HOD/LOD',             group = HODLOD_GROUP,   tooltip = 'Show High and Low of Day levels')
showPrevDayInput                = input(        false,      'Show PDH/PDL',             group = HODLOD_GROUP,   tooltip = 'Also show previous day high/low')
hodColorInput                   = input.color(  #FF6B6B,    'HOD/PDH Color',            group = HODLOD_GROUP)
lodColorInput                   = input.color(  #00BCD4,    'LOD/PDL Color',            group = HODLOD_GROUP)

// ===== 3. FAIR VALUE GAPS (Optional) =====
showFairValueGapsInput          = input(        false,      'Show FVG',                 group = GAPS_GROUP,     tooltip = showFairValueGapsTooltip)
fairValueGapsThresholdInput     = input(        true,       'Auto Threshold',           group = GAPS_GROUP,     tooltip = fairValueGapsThresholdTooltip)
fairValueGapsBullColorInput     = input.color(color.new(#00BCD4, 70), 'Bullish FVG' ,   group = GAPS_GROUP)
fairValueGapsBearColorInput     = input.color(color.new(#FF6B6B, 70), 'Bearish FVG' ,   group = GAPS_GROUP)
fairValueGapsExtendInput        = input.int(    1,          'Extend Bars',              group = GAPS_GROUP,     tooltip = fairValueGapsExtendTooltip,       minval = 0)
fairValueGapsTimeframeInput     = input.timeframe('',       'Timeframe',                group = GAPS_GROUP,     tooltip = fairValueGapsTimeframeTooltip)

// ===== 4. DAILY/WEEKLY/MONTHLY LEVELS (Optional) =====
showDailyLevelsInput            = input(        false,      'Daily',                    group = LEVELS_GROUP,   inline = 'daily')
dailyLevelsStyleInput           = input.string( SOLID,      '',                         group = LEVELS_GROUP,   inline = 'daily',   options = [SOLID,DASHED,DOTTED])
dailyLevelsColorInput           = input(        BLUE,       '',                         group = LEVELS_GROUP,   inline = 'daily')
showWeeklyLevelsInput           = input(        false,      'Weekly',                   group = LEVELS_GROUP,   inline = 'weekly')
weeklyLevelsStyleInput          = input.string( SOLID,      '',                         group = LEVELS_GROUP,   inline = 'weekly',  options = [SOLID,DASHED,DOTTED])
weeklyLevelsColorInput          = input(        BLUE,       '',                         group = LEVELS_GROUP,   inline = 'weekly')
showMonthlyLevelsInput          = input(        false,      'Monthly',                  group = LEVELS_GROUP,   inline = 'monthly')
monthlyLevelsStyleInput         = input.string( SOLID,      '',                         group = LEVELS_GROUP,   inline = 'monthly', options = [SOLID,DASHED,DOTTED])
monthlyLevelsColorInput         = input(        BLUE,       '',                         group = LEVELS_GROUP,   inline = 'monthly')

// ===== 5. PREMIUM/DISCOUNT ZONES (Optional) =====
showPremiumDiscountZonesInput   = input(        false,      'Show Zones',               group = ZONES_GROUP,    tooltip = showPremiumDiscountZonesTooltip)
premiumZoneColorInput           = input.color(  RED,        'Premium Zone',             group = ZONES_GROUP)
equilibriumZoneColorInput       = input.color(  GRAY,       'Equilibrium',              group = ZONES_GROUP)
discountZoneColorInput          = input.color(  GREEN,      'Discount Zone',            group = ZONES_GROUP)

// ===== 6. DISPLAY SETTINGS =====
modeInput                       = input.string( HISTORICAL, 'Mode',                     group = SMART_GROUP,    tooltip = modeTooltip, options = [HISTORICAL, PRESENT])
styleInput                      = input.string( COLORED,    'Style',                    group = SMART_GROUP,    tooltip = styleTooltip,options = [COLORED, MONOCHROME])
showTrendInput                  = input(        false,      'Color Candles',            group = SMART_GROUP,    tooltip = showTrendTooltip)

// ===== HIDDEN/DISABLED SETTINGS =====
// NOTE: Alerts are accessed via TradingView's "Create Alert" menu, not here
alertSupplyEntryInput           = true
alertDemandEntryInput           = true
alertMtfBullishInput            = true
alertMtfBearishInput            = true

// ===== HIDDEN/DISABLED SETTINGS =====
showInternalsInput              = false
showInternalBullInput           = ALL
internalBullColorInput          = GREEN
showInternalBearInput           = ALL
internalBearColorInput          = RED
internalFilterConfluenceInput   = false
internalStructureSize           = TINY
showStructureInput              = true
showSwingBullInput              = ALL
swingBullColorInput             = GREEN
showSwingBearInput              = ALL
swingBearColorInput             = RED
swingStructureSize              = SMALL
showSwingsInput                 = false
swingsLengthInput               = 50
showHighLowSwingsInput          = false
showEqualHighsLowsInput         = false
equalHighsLowsLengthInput       = 3
equalHighsLowsThresholdInput    = 0.1
equalHighsLowsSizeInput         = TINY


//---------------------------------------------------------------------------------------------------------------------}
//DATA STRUCTURES & VARIABLES
//---------------------------------------------------------------------------------------------------------------------{
// @type                            UDT representing alerts as bool fields
// @field internalBullishBOS        internal structure custom alert
// @field internalBearishBOS        internal structure custom alert
// @field internalBullishCHoCH      internal structure custom alert
// @field internalBearishCHoCH      internal structure custom alert
// @field swingBullishBOS           swing structure custom alert
// @field swingBearishBOS           swing structure custom alert
// @field swingBullishCHoCH         swing structure custom alert
// @field swingBearishCHoCH         swing structure custom alert
// @field internalBullishOrderBlock internal order block custom alert
// @field internalBearishOrderBlock internal order block custom alert
// @field swingBullishOrderBlock    swing order block custom alert
// @field swingBearishOrderBlock    swing order block custom alert
// @field equalHighs                equal high low custom alert
// @field equalLows                 equal high low custom alert
// @field bullishFairValueGap       fair value gap custom alert
// @field bearishFairValueGap       fair value gap custom alert
type alerts
    bool internalBullishBOS         = false
    bool internalBearishBOS         = false
    bool internalBullishCHoCH       = false
    bool internalBearishCHoCH       = false
    bool swingBullishBOS            = false
    bool swingBearishBOS            = false
    bool swingBullishCHoCH          = false
    bool swingBearishCHoCH          = false
    bool internalBullishOrderBlock  = false
    bool internalBearishOrderBlock  = false
    bool swingBullishOrderBlock     = false
    bool swingBearishOrderBlock     = false
    bool equalHighs                 = false
    bool equalLows                  = false
    bool bullishFairValueGap        = false
    bool bearishFairValueGap        = false
    // ===== ADDED: Custom rejection alerts =====
    bool demandRejection            = false
    bool supplyRejection            = false

// @type                            UDT representing last swing extremes (top & bottom)
// @field top                       last top swing price
// @field bottom                    last bottom swing price
// @field barTime                   last swing bar time
// @field barIndex                  last swing bar index
// @field lastTopTime               last top swing time
// @field lastBottomTime            last bottom swing time
type trailingExtremes
    float top
    float bottom
    int barTime
    int barIndex
    int lastTopTime
    int lastBottomTime

// @type                            UDT representing Fair Value Gaps
// @field top                       top price
// @field bottom                    bottom price
// @field bias                      bias (BULLISH or BEARISH)
// @field topBox                    top box
// @field bottomBox                 bottom box
type fairValueGap
    float top
    float bottom
    int bias
    box topBox
    box bottomBox

// @type                            UDT representing trend bias
// @field bias                      BULLISH or BEARISH
type trend
    int bias    

// @type                            UDT representing Equal Highs Lows display
// @field l_ine                     displayed line
// @field l_abel                    displayed label
type equalDisplay
    line l_ine      = na
    label l_abel    = na

// @type                            UDT representing a pivot point (swing point) 
// @field currentLevel              current price level
// @field lastLevel                 last price level
// @field crossed                   true if price level is crossed
// @field barTime                   bar time
// @field barIndex                  bar index    
type pivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime     = time
    int barIndex    = bar_index

// @type                            UDT representing an order block (Golden Zone)
// @field barHigh                   bar high
// @field barLow                    bar low
// @field barTime                   bar time
// @field barIndex                  bar index for time calculation
// @field bias                      BULLISH or BEARISH
// @field vol                       volume at creation
// @field retests                   number of times zone has been tested
type orderBlock
    float barHigh
    float barLow
    int barTime    
    int barIndex
    int bias
    float vol
    int retests = 0

// @variable                        current swing pivot high    
var pivot swingHigh                 = pivot.new(na,na,false)
// @variable                        current swing pivot low
var pivot swingLow                  = pivot.new(na,na,false)
// @variable                        current internal pivot high
var pivot internalHigh              = pivot.new(na,na,false)
// @variable                        current internal pivot low
var pivot internalLow               = pivot.new(na,na,false)
// @variable                        current equal high pivot
var pivot equalHigh                 = pivot.new(na,na,false)
// @variable                        current equal low pivot
var pivot equalLow                  = pivot.new(na,na,false)
// @variable                        swing trend bias
var trend swingTrend                = trend.new(0)
// @variable                        internal trend bias
var trend internalTrend             = trend.new(0)
// @variable                        equal high display
var equalDisplay equalHighDisplay   = equalDisplay.new()
// @variable                        equal low display
var equalDisplay equalLowDisplay    = equalDisplay.new()
// @variable                        storage for fairValueGap UDTs
var array<fairValueGap> fairValueGaps = array.new<fairValueGap>()
// @variable                        storage for parsed highs
var array<float> parsedHighs        = array.new<float>()
// @variable                        storage for parsed lows
var array<float> parsedLows         = array.new<float>()
// @variable                        storage for raw highs
var array<float> highs              = array.new<float>()
// @variable                        storage for raw lows
var array<float> lows               = array.new<float>()
// @variable                        storage for bar time values
var array<int> times                = array.new<int>()
// @variable                        last trailing swing high and low
var trailingExtremes trailing       = trailingExtremes.new()
// @variable                                storage for orderBlock UDTs (swing order blocks)
var array<orderBlock> swingOrderBlocks      = array.new<orderBlock>()
// @variable                                storage for orderBlock UDTs (internal order blocks)
var array<orderBlock> internalOrderBlocks   = array.new<orderBlock>()
// @variable                                storage for swing order blocks boxes
var array<box> swingOrderBlocksBoxes        = array.new<box>()
// @variable                                storage for internal order blocks boxes
var array<box> internalOrderBlocksBoxes     = array.new<box>()
// @variable                        color for swing bullish structures
var swingBullishColor               = styleInput == MONOCHROME ? MONO_BULLISH : swingBullColorInput
// @variable                        color for swing bearish structures
var swingBearishColor               = styleInput == MONOCHROME ? MONO_BEARISH : swingBearColorInput
// @variable                        color for bullish fair value gaps
var fairValueGapBullishColor        = styleInput == MONOCHROME ? color.new(MONO_BULLISH,70) : fairValueGapsBullColorInput
// @variable                        color for bearish fair value gaps
var fairValueGapBearishColor        = styleInput == MONOCHROME ? color.new(MONO_BEARISH,70) : fairValueGapsBearColorInput
// @variable                        color for premium zone
var premiumZoneColor                = styleInput == MONOCHROME ? MONO_BEARISH : premiumZoneColorInput
// @variable                        color for discount zone
var discountZoneColor               = styleInput == MONOCHROME ? MONO_BULLISH : discountZoneColorInput 
// @variable                        bar index on current script iteration
varip int currentBarIndex           = bar_index
// @variable                        bar index on last script iteration
varip int lastBarIndex              = bar_index
// @variable                        alerts in current bar
alerts currentAlerts                = alerts.new()
// @variable                        time at start of chart
var initialTime                     = time

// we create the needed boxes for displaying order blocks at the first execution
if barstate.isfirst
    if showSwingOrderBlocksInput
        for index = 1 to swingOrderBlocksSizeInput
            swingOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))
    if showInternalOrderBlocksInput
        for index = 1 to internalOrderBlocksSizeInput
            internalOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))

// ===== AUTO TIMEFRAME SCALING =====
// Automatically adjust lookback periods for ALL TradingView timeframes
tfSeconds = timeframe.in_seconds()

// Internal structure lookback (scales for all timeframes)
// Seconds (1s-45s): 8 bars | 1min: 5 | 5min: 4 | 15min: 3 | 1H+: 2
autoInternalLookback = tfSeconds < 60 ? 8 : tfSeconds <= 60 ? 5 : tfSeconds <= 300 ? 4 : tfSeconds <= 900 ? 3 : 2

// Swing structure lookback (scales for all timeframes)
// Seconds: 100 | 1min: 50 | 5min: 30 | 15min: 20 | 1H: 15 | 4H: 12 | Daily: 10 | Weekly+: 8
autoSwingLookback = tfSeconds < 60 ? 100 : tfSeconds <= 60 ? 50 : tfSeconds <= 300 ? 30 : tfSeconds <= 900 ? 20 : tfSeconds <= 3600 ? 15 : tfSeconds <= 14400 ? 12 : tfSeconds <= 86400 ? 10 : 8



// @variable                        source to use in bearish order blocks mitigation
bearishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : high
// @variable                        source to use in bullish order blocks mitigation
bullishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : low
// @variable                        default volatility measure
atrMeasure                          = ta.atr(200)
// @variable                        parsed volatility measure by user settings
volatilityMeasure                   = orderBlockFilterInput == ATR ? atrMeasure : ta.cum(ta.tr)/bar_index
// @variable                        true if current bar is a high volatility bar
highVolatilityBar                   = (high - low) >= (2 * volatilityMeasure)
// @variable                        parsed high
parsedHigh                          = highVolatilityBar ? low : high
// @variable                        parsed low
parsedLow                           = highVolatilityBar ? high : low

// we store current values into the arrays at each bar
parsedHighs.push(parsedHigh)
parsedLows.push(parsedLow)
highs.push(high)
lows.push(low)
times.push(time)

//---------------------------------------------------------------------------------------------------------------------}
//USER-DEFINED FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
// @function            Get the value of the current leg, it can be 0 (bearish) or 1 (bullish)
// @returns             int
leg(int size) =>
    var leg     = 0    
    newLegHigh  = high[size] > ta.highest( size)
    newLegLow   = low[size]  < ta.lowest(  size)
    
    if newLegHigh
        leg := BEARISH_LEG
    else if newLegLow
        leg := BULLISH_LEG
    leg

// @function            Identify whether the current value is the start of a new leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfNewLeg(int leg)      => ta.change(leg) != 0

// @function            Identify whether the current level is the start of a new bearish leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfBearishLeg(int leg)  => ta.change(leg) == -1

// @function            Identify whether the current level is the start of a new bullish leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfBullishLeg(int leg)  => ta.change(leg) == +1

// @function            create a new label
// @param labelTime     bar time coordinate
// @param labelPrice    price coordinate
// @param tag           text to display
// @param labelColor    text color
// @param labelStyle    label style
// @returns             label ID
drawLabel(int labelTime, float labelPrice, string tag, color labelColor, string labelStyle) =>    
    var label l_abel = na

    if modeInput == PRESENT
        l_abel.delete()

    l_abel := label.new(chart.point.new(labelTime,na,labelPrice),tag,xloc.bar_time,color=color(na),textcolor=labelColor,style = labelStyle,size = size.small)

// @function            create a new line and label representing an EQH or EQL
// @param p_ivot        starting pivot
// @param level         price level of current pivot
// @param size          how many bars ago was the current pivot detected
// @param equalHigh     true for EQH, false for EQL
// @returns             label ID
drawEqualHighLow(pivot p_ivot, float level, int size, bool equalHigh) =>
    equalDisplay e_qualDisplay = equalHigh ? equalHighDisplay : equalLowDisplay
    
    string tag          = 'EQL'
    color equalColor    = swingBullishColor
    string labelStyle   = label.style_label_up

    if equalHigh
        tag         := 'EQH'
        equalColor  := swingBearishColor
        labelStyle  := label.style_label_down

    if modeInput == PRESENT
        line.delete(    e_qualDisplay.l_ine)
        label.delete(   e_qualDisplay.l_abel)
        
    e_qualDisplay.l_ine     := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time[size],na,level), xloc = xloc.bar_time, color = equalColor, style = line.style_dotted)
    labelPosition           = math.round(0.5*(p_ivot.barIndex + bar_index - size))
    e_qualDisplay.l_abel    := label.new(chart.point.new(na,labelPosition,level), tag, xloc.bar_index, color = color(na), textcolor = equalColor, style = labelStyle, size = equalHighsLowsSizeInput)

// @function            store current structure and trailing swing points, and also display swing points and equal highs/lows
// @param size          (int) structure size
// @param equalHighLow  (bool) true for displaying current highs/lows
// @param internal      (bool) true for getting internal structures
// @returns             label ID
getCurrentStructure(int size,bool equalHighLow = false, bool internal = false) =>        
    currentLeg              = leg(size)
    newPivot                = startOfNewLeg(currentLeg)
    pivotLow                = startOfBullishLeg(currentLeg)
    pivotHigh               = startOfBearishLeg(currentLeg)

    if newPivot
        if pivotLow
            pivot p_ivot    = equalHighLow ? equalLow : internal ? internalLow : swingLow    

            // EQL labels disabled for cleaner look
            // if equalHighLow and math.abs(p_ivot.currentLevel - low[size]) < equalHighsLowsThresholdInput * atrMeasure                
            //     drawEqualHighLow(p_ivot, low[size], size, false)
            //     currentAlerts.equalLows := true

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := low[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                trailing.bottom         := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastBottomTime := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel < p_ivot.lastLevel ? 'LL' : 'HL', swingBullishColor, label.style_label_up)            
        else
            pivot p_ivot = equalHighLow ? equalHigh : internal ? internalHigh : swingHigh

            // EQH labels disabled for cleaner look
            // if equalHighLow and math.abs(p_ivot.currentLevel - high[size]) < equalHighsLowsThresholdInput * atrMeasure
            //     drawEqualHighLow(p_ivot,high[size],size,true)
            //     currentAlerts.equalHighs := true               

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := high[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                trailing.top            := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastTopTime    := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel > p_ivot.lastLevel ? 'HH' : 'LH', swingBearishColor, label.style_label_down)
                
// @function                draw line and label representing a structure
// @param p_ivot            base pivot point
// @param tag               test to display
// @param structureColor    base color
// @param lineStyle         line style
// @param labelStyle        label style
// @param labelSize         text size
// @returns                 label ID
drawStructure(pivot p_ivot, string tag, color structureColor, string lineStyle, string labelStyle, string labelSize) =>    
    var line l_ine      = line.new(na,na,na,na,xloc = xloc.bar_time)
    var label l_abel    = label.new(na,na)

    if modeInput == PRESENT
        l_ine.delete()
        l_abel.delete()

    l_ine   := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time,na,p_ivot.currentLevel), xloc.bar_time, color=structureColor, style=lineStyle)
    l_abel  := label.new(chart.point.new(na,math.round(0.5*(p_ivot.barIndex+bar_index)),p_ivot.currentLevel), tag, xloc.bar_index, color=color(na), textcolor=structureColor, style=labelStyle, size = labelSize)

// @function            delete order blocks (or increment retest count)
// @param internal      true for internal order blocks
// @returns             orderBlock ID
deleteOrderBlocks(bool internal = false) =>
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks

    for [index,eachOrderBlock] in orderBlocks
        bool touchedZone = false
        bool mitigatedZone = false
        
        // Check if price is touching/inside the zone (for retest counting)
        bool inSupplyZone = eachOrderBlock.bias == BEARISH and high >= eachOrderBlock.barLow and high <= eachOrderBlock.barHigh
        bool inDemandZone = eachOrderBlock.bias == BULLISH and low <= eachOrderBlock.barHigh and low >= eachOrderBlock.barLow
        
        // Check for full mitigation (price closes through zone)
        if bearishOrderBlockMitigationSource > eachOrderBlock.barHigh and eachOrderBlock.bias == BEARISH
            mitigatedZone := true
            if internal
                currentAlerts.internalBearishOrderBlock := true
            else
                currentAlerts.swingBearishOrderBlock    := true
        else if bullishOrderBlockMitigationSource < eachOrderBlock.barLow and eachOrderBlock.bias == BULLISH
            mitigatedZone := true
            if internal
                currentAlerts.internalBullishOrderBlock := true
            else
                currentAlerts.swingBullishOrderBlock    := true
        else if inSupplyZone or inDemandZone
            // Price is touching the zone - increment retest on new bar
            if barstate.isconfirmed
                eachOrderBlock.retests := eachOrderBlock.retests + 1
        
        if mitigatedZone                    
            orderBlocks.remove(index)            

// @function            fetch and store order blocks
// @param p_ivot        base pivot point
// @param internal      true for internal order blocks
// @param bias          BULLISH or BEARISH
// @returns             void
storeOrdeBlock(pivot p_ivot,bool internal = false,int bias) =>
    if (not internal and showSwingOrderBlocksInput) or (internal and showInternalOrderBlocksInput)

        array<float> a_rray = na
        int parsedIndex = na

        if bias == BEARISH
            a_rray      := parsedHighs.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.max())  
        else
            a_rray      := parsedLows.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.min())                        

        orderBlock o_rderBlock          = orderBlock.new(parsedHighs.get(parsedIndex), parsedLows.get(parsedIndex), times.get(parsedIndex), parsedIndex, bias, volume[bar_index - parsedIndex])
        array<orderBlock> orderBlocks   = internal ? internalOrderBlocks : swingOrderBlocks
        
        if orderBlocks.size() >= 100
            orderBlocks.pop()
        orderBlocks.unshift(o_rderBlock)
        
        // ===== IMMEDIATE NEW ZONE ALERT =====
        string zoneType = bias == BULLISH ? "demand" : "supply"
        float zoneSize = o_rderBlock.barHigh - o_rderBlock.barLow
        string strength = zoneSize > atrMeasure ? "STRONG" : zoneSize > atrMeasure * 0.5 ? "MEDIUM" : "WEAK"
        string newZonePayload = str.format('{"action":"NEW","sym":"{0}","type":"{1}","t":{2},"b":{3},"s":"{4}"}',
            syminfo.ticker, zoneType, o_rderBlock.barHigh, o_rderBlock.barLow, strength)
        alert(newZonePayload, alert.freq_once_per_bar)

// @function            draw order blocks (Golden Zones) as boxes with info
// @param internal      true for internal order blocks
// @returns             void
drawOrderBlocks(bool internal = false) =>        
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
    orderBlocksSize = orderBlocks.size()

    if orderBlocksSize > 0        
        maxOrderBlocks                      = internal ? internalOrderBlocksSizeInput : swingOrderBlocksSizeInput
        array<orderBlock> parsedOrdeBlocks  = orderBlocks.slice(0, math.min(maxOrderBlocks,orderBlocksSize))
        array<box> b_oxes                   = internal ? internalOrderBlocksBoxes : swingOrderBlocksBoxes        

        for [index,eachOrderBlock] in parsedOrdeBlocks
            // ===== MODERN ZONE COLORS =====
            // Demand zones: Teal/Cyan gradient | Supply zones: Coral/Magenta gradient
            bool isSupply = eachOrderBlock.bias == BEARISH
            
            // ===== ZONE STRENGTH CALCULATION =====
            // Factors: freshness (retests), zone size, recency
            float zoneSize = eachOrderBlock.barHigh - eachOrderBlock.barLow
            int barsAgo = bar_index - eachOrderBlock.barIndex
            
            // Score components (0-100 scale)
            float freshnessScore = eachOrderBlock.retests == 0 ? 40 : eachOrderBlock.retests == 1 ? 20 : 0
            float sizeScore = zoneSize > atrMeasure ? 30 : zoneSize > atrMeasure * 0.5 ? 20 : 10
            float recencyScore = barsAgo < 50 ? 30 : barsAgo < 100 ? 20 : 10
            
            // Total strength score
            float strengthScore = freshnessScore + sizeScore + recencyScore
            
            // Strength label
            string zoneStrength = strengthScore >= 70 ? "STRONG" : strengthScore >= 40 ? "MEDIUM" : "WEAK"
            
            // Color intensity based on strength
            int transparency = strengthScore >= 70 ? 65 : strengthScore >= 40 ? 78 : 88
            
            // Modern color selection
            color zoneColor = na
            color borderColor = na
            if styleInput == MONOCHROME
                zoneColor := isSupply ? color.new(MONO_BEARISH, transparency) : color.new(MONO_BULLISH, transparency)
                borderColor := isSupply ? MONO_BEARISH : MONO_BULLISH
            else
                if internal
                    zoneColor := isSupply ? color.new(SUPPLY_SECONDARY, transparency) : color.new(DEMAND_SECONDARY, transparency)
                    borderColor := isSupply ? SUPPLY_SECONDARY : DEMAND_SECONDARY
                else
                    zoneColor := isSupply ? color.new(SUPPLY_PRIMARY, transparency) : color.new(DEMAND_PRIMARY, transparency)
                    borderColor := isSupply ? SUPPLY_PRIMARY : DEMAND_PRIMARY

            box b_ox        = b_oxes.get(index)
            b_ox.set_top_left_point(    chart.point.new(eachOrderBlock.barTime,na,eachOrderBlock.barHigh))
            b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,eachOrderBlock.barLow))        
            b_ox.set_border_color(      borderColor)
            b_ox.set_border_width(      internal ? 1 : 2)
            b_ox.set_bgcolor(           zoneColor)
            
            // ===== ZONE LABEL WITH AGE =====
            // Label ALL zones (swing and internal)
            if barstate.islast
                zoneMidPrice = math.avg(eachOrderBlock.barHigh, eachOrderBlock.barLow)
                zoneLabel = isSupply ? "SUPPLY" : "DEMAND"
                
                // Calculate zone age in minutes
                int zoneAgeMs = time - eachOrderBlock.barTime
                int zoneAgeMins = zoneAgeMs / 60000
                
                // Format age label
                string ageText = ""
                if zoneAgeMins < 60
                    ageText := str.tostring(zoneAgeMins) + "m"
                else if zoneAgeMins < 120
                    ageText := "1H"
                else if zoneAgeMins < 240
                    ageText := str.tostring(math.floor(zoneAgeMins / 60)) + "H"
                else if zoneAgeMins < 480
                    ageText := "4H"
                else if zoneAgeMins < 1440
                    ageText := str.tostring(math.floor(zoneAgeMins / 60)) + "H"
                else
                    int days = math.floor(zoneAgeMins / 1440)
                    ageText := str.tostring(days) + "D"
                
                labelText = zoneLabel + " ‚Ä¢ " + zoneStrength + " ‚Ä¢ " + ageText
                labelColor = isSupply ? SUPPLY_PRIMARY : DEMAND_PRIMARY
                // Position label at right edge of zone (current time) for visibility
                label.new(chart.point.new(last_bar_time, na, zoneMidPrice), labelText, xloc.bar_time, color = color(na), textcolor = labelColor, style = label.style_label_left, size = size.small)

// @function            detect and draw structures, also detect and store order blocks
// @param internal      true for internal structures or order blocks
// @returns             void
displayStructure(bool internal = false) =>
    var bullishBar = true
    var bearishBar = true

    if internalFilterConfluenceInput
        bullishBar := high - math.max(close, open) > math.min(close, open - low)
        bearishBar := high - math.max(close, open) < math.min(close, open - low)
    
    pivot p_ivot    = internal ? internalHigh : swingHigh
    trend t_rend    = internal ? internalTrend : swingTrend

    lineStyle       = internal ? line.style_dashed : line.style_solid
    labelSize       = internal ? internalStructureSize : swingStructureSize

    extraCondition  = internal ? internalHigh.currentLevel != swingHigh.currentLevel and bullishBar : true
    bullishColor    = styleInput == MONOCHROME ? MONO_BULLISH : internal ? internalBullColorInput : swingBullColorInput

    if ta.crossover(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BEARISH ? CHOCH : BOS

        if internal
            currentAlerts.internalBullishCHoCH  := tag == CHOCH
            currentAlerts.internalBullishBOS    := tag == BOS
        else
            currentAlerts.swingBullishCHoCH     := tag == CHOCH
            currentAlerts.swingBullishBOS       := tag == BOS

        p_ivot.crossed  := true
        t_rend.bias     := BULLISH

        displayCondition = internal ? showInternalsInput and (showInternalBullInput == ALL or (showInternalBullInput == BOS and tag != CHOCH) or (showInternalBullInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBullInput == ALL or (showSwingBullInput == BOS and tag != CHOCH) or (showSwingBullInput == CHOCH and tag == CHOCH))

        // BOS/CHoCH labels disabled for cleaner look - logic still runs for zone detection
        // if displayCondition                        
        //     drawStructure(p_ivot,tag,bullishColor,lineStyle,label.style_label_down,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BULLISH)

    p_ivot          := internal ? internalLow : swingLow    
    extraCondition  := internal ? internalLow.currentLevel != swingLow.currentLevel and bearishBar : true
    bearishColor    = styleInput == MONOCHROME ? MONO_BEARISH : internal ? internalBearColorInput : swingBearColorInput

    if ta.crossunder(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BULLISH ? CHOCH : BOS

        if internal
            currentAlerts.internalBearishCHoCH  := tag == CHOCH
            currentAlerts.internalBearishBOS    := tag == BOS
        else
            currentAlerts.swingBearishCHoCH     := tag == CHOCH
            currentAlerts.swingBearishBOS       := tag == BOS

        p_ivot.crossed := true
        t_rend.bias := BEARISH

        displayCondition = internal ? showInternalsInput and (showInternalBearInput == ALL or (showInternalBearInput == BOS and tag != CHOCH) or (showInternalBearInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBearInput == ALL or (showSwingBearInput == BOS and tag != CHOCH) or (showSwingBearInput == CHOCH and tag == CHOCH))
        
        // BOS/CHoCH labels disabled for cleaner look - logic still runs for zone detection
        // if displayCondition                        
        //     drawStructure(p_ivot,tag,bearishColor,lineStyle,label.style_label_up,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BEARISH)

// @function            draw one fair value gap box (each fair value gap has two boxes)
// @param leftTime      left time coordinate
// @param rightTime     right time coordinate
// @param topPrice      top price level
// @param bottomPrice   bottom price level
// @param boxColor      box color
// @returns             box ID
fairValueGapBox(leftTime,rightTime,topPrice,bottomPrice,boxColor) => box.new(chart.point.new(leftTime,na,topPrice),chart.point.new(rightTime + fairValueGapsExtendInput * (time-time[1]),na,bottomPrice), xloc=xloc.bar_time, border_color = boxColor, bgcolor = boxColor)

// @function            delete fair value gaps
// @returns             fairValueGap ID
deleteFairValueGaps() =>
    for [index,eachFairValueGap] in fairValueGaps
        if (low < eachFairValueGap.bottom and eachFairValueGap.bias == BULLISH) or (high > eachFairValueGap.top and eachFairValueGap.bias == BEARISH)
            eachFairValueGap.topBox.delete()
            eachFairValueGap.bottomBox.delete()
            fairValueGaps.remove(index)
    
// @function            draw fair value gaps
// @returns             fairValueGap ID
drawFairValueGaps() => 
    [lastClose, lastOpen, lastTime, currentHigh, currentLow, currentTime, last2High, last2Low] = request.security(syminfo.tickerid, fairValueGapsTimeframeInput, [close[1], open[1], time[1], high[0], low[0], time[0], high[2], low[2]], lookahead = barmerge.lookahead_off)

    barDeltaPercent     = (lastClose - lastOpen) / (lastOpen * 100)
    newTimeframe        = timeframe.change(fairValueGapsTimeframeInput)
    threshold           = fairValueGapsThresholdInput ? ta.cum(math.abs(newTimeframe ? barDeltaPercent : 0)) / bar_index * 2 : 0

    bullishFairValueGap = currentLow > last2High and lastClose > last2High and barDeltaPercent > threshold and newTimeframe
    bearishFairValueGap = currentHigh < last2Low and lastClose < last2Low and -barDeltaPercent > threshold and newTimeframe

    if bullishFairValueGap
        currentAlerts.bullishFairValueGap := true
        fairValueGaps.unshift(fairValueGap.new(currentLow,last2High,BULLISH,fairValueGapBox(lastTime,currentTime,currentLow,math.avg(currentLow,last2High),fairValueGapBullishColor),fairValueGapBox(lastTime,currentTime,math.avg(currentLow,last2High),last2High,fairValueGapBullishColor)))
    if bearishFairValueGap
        currentAlerts.bearishFairValueGap := true
        fairValueGaps.unshift(fairValueGap.new(currentHigh,last2Low,BEARISH,fairValueGapBox(lastTime,currentTime,currentHigh,math.avg(currentHigh,last2Low),fairValueGapBearishColor),fairValueGapBox(lastTime,currentTime,math.avg(currentHigh,last2Low),last2Low,fairValueGapBearishColor)))

// @function            get line style from string
// @param style         line style
// @returns             string
getStyle(string style) =>
    switch style
        SOLID => line.style_solid
        DASHED => line.style_dashed
        DOTTED => line.style_dotted

// @function            draw MultiTimeFrame levels
// @param timeframe     base timeframe
// @param sameTimeframe true if chart timeframe is same as base timeframe
// @param style         line style
// @param levelColor    line and text color
// @returns             void
drawLevels(string timeframe, bool sameTimeframe, string style, color levelColor) =>
    [topLevel, bottomLevel, leftTime, rightTime] = request.security(syminfo.tickerid, timeframe, [high[1], low[1], time[1], time], lookahead = barmerge.lookahead_off)

    float parsedTop         = sameTimeframe ? high : topLevel
    float parsedBottom      = sameTimeframe ? low : bottomLevel    

    int parsedLeftTime      = sameTimeframe ? time : leftTime
    int parsedRightTime     = sameTimeframe ? time : rightTime

    int parsedTopTime       = time
    int parsedBottomTime    = time

    if not sameTimeframe
        int leftIndex               = times.binary_search_rightmost(parsedLeftTime)
        int rightIndex              = times.binary_search_rightmost(parsedRightTime)

        array<int> timeArray        = times.slice(leftIndex,rightIndex)
        array<float> topArray       = highs.slice(leftIndex,rightIndex)
        array<float> bottomArray    = lows.slice(leftIndex,rightIndex)

        parsedTopTime               := timeArray.size() > 0 ? timeArray.get(topArray.indexof(topArray.max())) : initialTime
        parsedBottomTime            := timeArray.size() > 0 ? timeArray.get(bottomArray.indexof(bottomArray.min())) : initialTime

    var line topLine        = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var line bottomLine     = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var label topLabel      = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}H',timeframe), color=color(na), textcolor = levelColor, size = size.small, style = label.style_label_left)
    var label bottomLabel   = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}L',timeframe), color=color(na), textcolor = levelColor, size = size.small, style = label.style_label_left)

    topLine.set_first_point(    chart.point.new(parsedTopTime,na,parsedTop))
    topLine.set_second_point(   chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))   
    topLabel.set_point(         chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))

    bottomLine.set_first_point( chart.point.new(parsedBottomTime,na,parsedBottom))    
    bottomLine.set_second_point(chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))
    bottomLabel.set_point(      chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))

// @function            true if chart timeframe is higher than provided timeframe
// @param timeframe     timeframe to check
// @returns             bool
higherTimeframe(string timeframe) => timeframe.in_seconds() > timeframe.in_seconds(timeframe)

// @function            update trailing swing points
// @returns             int
updateTrailingExtremes() =>
    trailing.top            := math.max(high,trailing.top)
    trailing.lastTopTime    := trailing.top == high ? time : trailing.lastTopTime
    trailing.bottom         := math.min(low,trailing.bottom)
    trailing.lastBottomTime := trailing.bottom == low ? time : trailing.lastBottomTime

// @function            draw trailing swing points
// @returns             void
drawHighLowSwings() =>
    var line topLine        = line.new(na, na, na, na, color = swingBearishColor, xloc = xloc.bar_time)
    var line bottomLine     = line.new(na, na, na, na, color = swingBullishColor, xloc = xloc.bar_time)
    var label topLabel      = label.new(na, na, color=color(na), textcolor = swingBearishColor, xloc = xloc.bar_time, style = label.style_label_down, size = size.tiny)
    var label bottomLabel   = label.new(na, na, color=color(na), textcolor = swingBullishColor, xloc = xloc.bar_time, style = label.style_label_up, size = size.tiny)

    rightTimeBar            = last_bar_time + 20 * (time - time[1])

    topLine.set_first_point(    chart.point.new(trailing.lastTopTime, na, trailing.top))
    topLine.set_second_point(   chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_point(         chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_text(          swingTrend.bias == BEARISH ? 'Strong High' : 'Weak High')

    bottomLine.set_first_point( chart.point.new(trailing.lastBottomTime, na, trailing.bottom))
    bottomLine.set_second_point(chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_point(      chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_text(       swingTrend.bias == BULLISH ? 'Strong Low' : 'Weak Low')

// @function            draw a zone with a label and a box
// @param labelLevel    price level for label
// @param labelIndex    bar index for label
// @param top           top price level for box
// @param bottom        bottom price level for box
// @param tag           text to display
// @param zoneColor     base color
// @param style         label style
// @returns             void
drawZone(float labelLevel, int labelIndex, float top, float bottom, string tag, color zoneColor, string style) =>
    var label l_abel    = label.new(na,na,text = tag, color=color(na),textcolor = zoneColor, style = style, size = size.small)
    var box b_ox        = box.new(na,na,na,na,bgcolor = color.new(zoneColor,80),border_color = color(na), xloc = xloc.bar_time)

    b_ox.set_top_left_point(    chart.point.new(trailing.barTime,na,top))
    b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,bottom))

    l_abel.set_point(           chart.point.new(na,labelIndex,labelLevel))

// @function            draw premium/discount zones
// @returns             void
drawPremiumDiscountZones() =>
    drawZone(trailing.top, math.round(0.5*(trailing.barIndex + last_bar_index)), trailing.top, 0.95*trailing.top + 0.05*trailing.bottom, 'Premium', premiumZoneColor, label.style_label_down)

    equilibriumLevel = math.avg(trailing.top, trailing.bottom)
    drawZone(equilibriumLevel, last_bar_index, 0.525*trailing.top + 0.475*trailing.bottom, 0.525*trailing.bottom + 0.475*trailing.top, 'Equilibrium', equilibriumZoneColorInput, label.style_label_left)

    drawZone(trailing.bottom, math.round(0.5*(trailing.barIndex + last_bar_index)), 0.95*trailing.bottom + 0.05*trailing.top, trailing.bottom, 'Discount', discountZoneColor, label.style_label_up)

//---------------------------------------------------------------------------------------------------------------------}
//MUTABLE VARIABLES & EXECUTION
//---------------------------------------------------------------------------------------------------------------------{
parsedOpen  = showTrendInput ? open : na
candleColor = internalTrend.bias == BULLISH ? swingBullishColor : swingBearishColor
plotcandle(parsedOpen,high,low,close,color = candleColor, wickcolor = candleColor, bordercolor = candleColor)

if showHighLowSwingsInput or showPremiumDiscountZonesInput
    updateTrailingExtremes()

    // Strong/Weak High/Low disabled for cleaner look
    // if showHighLowSwingsInput
    //     drawHighLowSwings()

    if showPremiumDiscountZonesInput
        drawPremiumDiscountZones()

if showFairValueGapsInput
    deleteFairValueGaps()

getCurrentStructure(autoSwingLookback, false)
getCurrentStructure(autoInternalLookback, false, true)

if showEqualHighsLowsInput
    getCurrentStructure(equalHighsLowsLengthInput,true)

if showInternalsInput or showInternalOrderBlocksInput or showTrendInput
    displayStructure(true)

if showStructureInput or showSwingOrderBlocksInput or showHighLowSwingsInput
    displayStructure()

if showInternalOrderBlocksInput
    deleteOrderBlocks(true)

if showSwingOrderBlocksInput
    deleteOrderBlocks()

if showFairValueGapsInput
    drawFairValueGaps()

if barstate.islastconfirmedhistory or barstate.islast
    if showInternalOrderBlocksInput        
        drawOrderBlocks(true)
        
    if showSwingOrderBlocksInput        
        drawOrderBlocks()

lastBarIndex    := currentBarIndex
currentBarIndex := bar_index
newBar          = currentBarIndex != lastBarIndex

if barstate.islastconfirmedhistory or (barstate.isrealtime and newBar)
    if showDailyLevelsInput and not higherTimeframe('D')
        drawLevels('D',timeframe.isdaily,dailyLevelsStyleInput,dailyLevelsColorInput)

    if showWeeklyLevelsInput and not higherTimeframe('W')
        drawLevels('W',timeframe.isweekly,weeklyLevelsStyleInput,weeklyLevelsColorInput)

    if showMonthlyLevelsInput and not higherTimeframe('M')
        drawLevels('M',timeframe.ismonthly,monthlyLevelsStyleInput,monthlyLevelsColorInput)

//---------------------------------------------------------------------------------------------------------------------}
//HOD/LOD (High/Low of Day)
//---------------------------------------------------------------------------------------------------------------------{
// Get daily high/low data
todayHigh = request.security(syminfo.tickerid, "D", high, lookahead = barmerge.lookahead_on)
todayLow = request.security(syminfo.tickerid, "D", low, lookahead = barmerge.lookahead_on)
prevDayHigh = request.security(syminfo.tickerid, "D", high[1], lookahead = barmerge.lookahead_off)
prevDayLow = request.security(syminfo.tickerid, "D", low[1], lookahead = barmerge.lookahead_off)

var line hodLine = na
var line lodLine = na
var line pdhLine = na
var line pdlLine = na
var label hodLabel = na
var label lodLabel = na
var label pdhLabel = na
var label pdlLabel = na

if showHodLodInput and barstate.islast
    // Clean up old lines/labels
    line.delete(hodLine)
    line.delete(lodLine)
    label.delete(hodLabel)
    label.delete(lodLabel)
    
    int rightTime = last_bar_time + 30 * (time - time[1])
    int leftTime = time - 100 * (time - time[1])
    
    // HOD line (resistance - coral)
    hodLine := line.new(chart.point.new(leftTime, na, todayHigh), chart.point.new(rightTime, na, todayHigh), xloc = xloc.bar_time, color = hodColorInput, style = line.style_solid, width = 2)
    hodLabel := label.new(chart.point.new(rightTime, na, todayHigh), "HOD", xloc = xloc.bar_time, color = color(na), textcolor = hodColorInput, style = label.style_label_left, size = size.small)
    
    // LOD line (support - teal)
    lodLine := line.new(chart.point.new(leftTime, na, todayLow), chart.point.new(rightTime, na, todayLow), xloc = xloc.bar_time, color = lodColorInput, style = line.style_solid, width = 2)
    lodLabel := label.new(chart.point.new(rightTime, na, todayLow), "LOD", xloc = xloc.bar_time, color = color(na), textcolor = lodColorInput, style = label.style_label_left, size = size.small)

if showHodLodInput and showPrevDayInput and barstate.islast
    // Clean up old lines/labels
    line.delete(pdhLine)
    line.delete(pdlLine)
    label.delete(pdhLabel)
    label.delete(pdlLabel)
    
    int rightTime = last_bar_time + 30 * (time - time[1])
    int leftTime = time - 100 * (time - time[1])
    
    // PDH line (previous day high - faded coral)
    pdhLine := line.new(chart.point.new(leftTime, na, prevDayHigh), chart.point.new(rightTime, na, prevDayHigh), xloc = xloc.bar_time, color = color.new(hodColorInput, 50), style = line.style_dashed, width = 1)
    pdhLabel := label.new(chart.point.new(rightTime, na, prevDayHigh), "PDH", xloc = xloc.bar_time, color = color(na), textcolor = color.new(hodColorInput, 50), style = label.style_label_left, size = size.tiny)
    
    // PDL line (previous day low - faded teal)
    pdlLine := line.new(chart.point.new(leftTime, na, prevDayLow), chart.point.new(rightTime, na, prevDayLow), xloc = xloc.bar_time, color = color.new(lodColorInput, 50), style = line.style_dashed, width = 1)
    pdlLabel := label.new(chart.point.new(rightTime, na, prevDayLow), "PDL", xloc = xloc.bar_time, color = color(na), textcolor = color.new(lodColorInput, 50), style = label.style_label_left, size = size.tiny)

//---------------------------------------------------------------------------------------------------------------------}
//DASHBOARD PANEL
//---------------------------------------------------------------------------------------------------------------------{
var table dashboard = table.new(position.top_right, 2, 4, bgcolor = color.new(PANEL_BG, 5), border_width = 1, border_color = PANEL_BORDER, frame_width = 1, frame_color = PANEL_BORDER)

// Count zones and find nearest
supplyCount = 0
demandCount = 0
nearestSupplyDist = 999999.0
nearestDemandDist = 999999.0

// Count and measure swing zones
if showSwingOrderBlocksInput
    maxSwing = math.min(swingOrderBlocksSizeInput, swingOrderBlocks.size())
    if maxSwing > 0
        for i = 0 to maxSwing - 1
            ob = swingOrderBlocks.get(i)
            if ob.bias == BEARISH
                supplyCount += 1
                dist = ob.barLow - close
                if dist > 0 and dist < nearestSupplyDist
                    nearestSupplyDist := dist
            else
                demandCount += 1
                dist = close - ob.barHigh
                if dist > 0 and dist < nearestDemandDist
                    nearestDemandDist := dist

// Count and measure internal zones
if showInternalOrderBlocksInput
    maxInternal = math.min(internalOrderBlocksSizeInput, internalOrderBlocks.size())
    if maxInternal > 0
        for i = 0 to maxInternal - 1
            ob = internalOrderBlocks.get(i)
            if ob.bias == BEARISH
                supplyCount += 1
                dist = ob.barLow - close
                if dist > 0 and dist < nearestSupplyDist
                    nearestSupplyDist := dist
            else
                demandCount += 1
                dist = close - ob.barHigh
                if dist > 0 and dist < nearestDemandDist
                    nearestDemandDist := dist

// Determine market bias
string marketBias = swingTrend.bias == BULLISH ? "BULLISH" : swingTrend.bias == BEARISH ? "BEARISH" : "NEUTRAL"
color biasColor = swingTrend.bias == BULLISH ? DEMAND_PRIMARY : swingTrend.bias == BEARISH ? SUPPLY_PRIMARY : GRAY

// Format distances
string supplyDistText = nearestSupplyDist < 999999 ? str.tostring(nearestSupplyDist, "#.##") : "‚Äî"
string demandDistText = nearestDemandDist < 999999 ? str.tostring(nearestDemandDist, "#.##") : "‚Äî"

// Update dashboard
if barstate.islast
    // Row 0: Bias
    table.cell(dashboard, 0, 0, "Bias", text_color = GRAY, text_size = size.small, text_halign = text.align_left)
    table.cell(dashboard, 1, 0, marketBias, text_color = biasColor, text_size = size.small, text_halign = text.align_right)
    
    // Row 1: Supply zones
    table.cell(dashboard, 0, 1, "Supply", text_color = SUPPLY_PRIMARY, text_size = size.small, text_halign = text.align_left)
    table.cell(dashboard, 1, 1, str.tostring(supplyCount), text_color = color.white, text_size = size.small, text_halign = text.align_right)
    
    // Row 2: Demand zones
    table.cell(dashboard, 0, 2, "Demand", text_color = DEMAND_PRIMARY, text_size = size.small, text_halign = text.align_left)
    table.cell(dashboard, 1, 2, str.tostring(demandCount), text_color = color.white, text_size = size.small, text_halign = text.align_right)
    
    // Row 3: Nearest zone distance
    table.cell(dashboard, 0, 3, "Nearest", text_color = GRAY, text_size = size.tiny, text_halign = text.align_left)
    nearestText = nearestDemandDist < nearestSupplyDist ? "‚ñº " + demandDistText : "‚ñ≤ " + supplyDistText
    nearestColor = nearestDemandDist < nearestSupplyDist ? DEMAND_PRIMARY : SUPPLY_PRIMARY
    table.cell(dashboard, 1, 3, nearestText, text_color = nearestColor, text_size = size.tiny, text_halign = text.align_right)

//---------------------------------------------------------------------------------------------------------------------}
//MTF BIAS BAR
//---------------------------------------------------------------------------------------------------------------------{
// Get trend from multiple timeframes using simple EMA crossover
getBias(tf) =>
    ema20 = request.security(syminfo.tickerid, tf, ta.ema(close, 20), lookahead = barmerge.lookahead_off)
    ema50 = request.security(syminfo.tickerid, tf, ta.ema(close, 50), lookahead = barmerge.lookahead_off)
    ema20 > ema50 ? 1 : -1

// Get bias for each timeframe
bias1m = getBias("1")
bias5m = getBias("5")
bias15m = getBias("15")
bias1h = getBias("60")
bias4h = getBias("240")
biasD = getBias("D")

// Create premium MTF Bias table (6 columns)
var table mtfBar = table.new(position.top_right, 6, 2, bgcolor = color.new(#1a1a2e, 5), border_width = 1, border_color = color.new(#4a4a6a, 50), frame_width = 1, frame_color = color.new(#4a4a6a, 50))

if barstate.islast
    // Header row
    table.cell(mtfBar, 0, 0, "1m", text_color = color.white, text_size = size.tiny, text_halign = text.align_center, bgcolor = color.new(#2d2d44, 0))
    table.cell(mtfBar, 1, 0, "5m", text_color = color.white, text_size = size.tiny, text_halign = text.align_center, bgcolor = color.new(#2d2d44, 0))
    table.cell(mtfBar, 2, 0, "15m", text_color = color.white, text_size = size.tiny, text_halign = text.align_center, bgcolor = color.new(#2d2d44, 0))
    table.cell(mtfBar, 3, 0, "1H", text_color = color.white, text_size = size.tiny, text_halign = text.align_center, bgcolor = color.new(#2d2d44, 0))
    table.cell(mtfBar, 4, 0, "4H", text_color = color.white, text_size = size.tiny, text_halign = text.align_center, bgcolor = color.new(#2d2d44, 0))
    table.cell(mtfBar, 5, 0, "D", text_color = color.white, text_size = size.tiny, text_halign = text.align_center, bgcolor = color.new(#2d2d44, 0))
    
    // Bias row with colored backgrounds
    // 1m
    bg1m = bias1m == 1 ? color.new(DEMAND_PRIMARY, 30) : color.new(SUPPLY_PRIMARY, 30)
    table.cell(mtfBar, 0, 1, bias1m == 1 ? "‚ñ≤" : "‚ñº", text_color = color.white, text_size = size.small, text_halign = text.align_center, bgcolor = bg1m)
    
    // 5m
    bg5m = bias5m == 1 ? color.new(DEMAND_PRIMARY, 30) : color.new(SUPPLY_PRIMARY, 30)
    table.cell(mtfBar, 1, 1, bias5m == 1 ? "‚ñ≤" : "‚ñº", text_color = color.white, text_size = size.small, text_halign = text.align_center, bgcolor = bg5m)
    
    // 15m
    bg15m = bias15m == 1 ? color.new(DEMAND_PRIMARY, 30) : color.new(SUPPLY_PRIMARY, 30)
    table.cell(mtfBar, 2, 1, bias15m == 1 ? "‚ñ≤" : "‚ñº", text_color = color.white, text_size = size.small, text_halign = text.align_center, bgcolor = bg15m)
    
    // 1H
    bg1h = bias1h == 1 ? color.new(DEMAND_PRIMARY, 30) : color.new(SUPPLY_PRIMARY, 30)
    table.cell(mtfBar, 3, 1, bias1h == 1 ? "‚ñ≤" : "‚ñº", text_color = color.white, text_size = size.small, text_halign = text.align_center, bgcolor = bg1h)
    
    // 4H
    bg4h = bias4h == 1 ? color.new(DEMAND_PRIMARY, 30) : color.new(SUPPLY_PRIMARY, 30)
    table.cell(mtfBar, 4, 1, bias4h == 1 ? "‚ñ≤" : "‚ñº", text_color = color.white, text_size = size.small, text_halign = text.align_center, bgcolor = bg4h)
    
    // Daily
    bgD = biasD == 1 ? color.new(DEMAND_PRIMARY, 30) : color.new(SUPPLY_PRIMARY, 30)
    table.cell(mtfBar, 5, 1, biasD == 1 ? "‚ñ≤" : "‚ñº", text_color = color.white, text_size = size.small, text_halign = text.align_center, bgcolor = bgD)

//---------------------------------------------------------------------------------------------------------------------}
//ALERTS
//---------------------------------------------------------------------------------------------------------------------{
// Track zone entry conditions
var bool wasInSupply = false
var bool wasInDemand = false
bool inSupplyZone = false
bool inDemandZone = false
float supplyZoneHigh = na
float demandZoneLow = na

// Check if price is in any supply/demand zone
if showSwingOrderBlocksInput
    for i = 0 to math.min(swingOrderBlocksSizeInput - 1, swingOrderBlocks.size() - 1)
        if i >= 0 and i < swingOrderBlocks.size()
            ob = swingOrderBlocks.get(i)
            if ob.bias == BEARISH and close >= ob.barLow and close <= ob.barHigh
                inSupplyZone := true
                supplyZoneHigh := ob.barHigh
            if ob.bias == BULLISH and close >= ob.barLow and close <= ob.barHigh
                inDemandZone := true
                demandZoneLow := ob.barLow

// Zone entry alerts
supplyEntryAlert = alertSupplyEntryInput and inSupplyZone and not wasInSupply
demandEntryAlert = alertDemandEntryInput and inDemandZone and not wasInDemand

// Rejection detection (REAL-TIME - fires when body pushes out, don't wait for close)
// Supply rejection = wick touched supply but body pushed back below (bearish rejection)
supplyRejection = high >= supplyZoneHigh and not na(supplyZoneHigh) and close < supplyZoneHigh and open < supplyZoneHigh
// Demand rejection = wick touched demand but body pushed back above (bullish rejection)  
demandRejection = low <= demandZoneLow and not na(demandZoneLow) and close > demandZoneLow and open > demandZoneLow

// Update tracking
wasInSupply := inSupplyZone
wasInDemand := inDemandZone

// MTF confluence alerts
allBullish = bias1m == 1 and bias5m == 1 and bias15m == 1 and bias1h == 1 and bias4h == 1 and biasD == 1
allBearish = bias1m == -1 and bias5m == -1 and bias15m == -1 and bias1h == -1 and bias4h == -1 and biasD == -1

var bool wasAllBullish = false
var bool wasAllBearish = false

mtfBullishAlert = alertMtfBullishInput and allBullish and not wasAllBullish
mtfBearishAlert = alertMtfBearishInput and allBearish and not wasAllBearish

wasAllBullish := allBullish
wasAllBearish := allBearish

// Fire alerts
alertcondition(supplyEntryAlert, title = "Price Enters Supply Zone", message = "{{ticker}}: Price has entered a SUPPLY zone! Potential resistance.")
alertcondition(demandEntryAlert, title = "Price Enters Demand Zone", message = "{{ticker}}: Price has entered a DEMAND zone! Potential support.")
alertcondition(supplyRejection, title = "Supply Zone Rejection", message = "{{ticker}}: Price REJECTED from supply zone! Bearish signal - potential short.")
alertcondition(demandRejection, title = "Demand Zone Rejection", message = "{{ticker}}: Price REJECTED from demand zone! Bullish signal - potential long.")
alertcondition(mtfBullishAlert, title = "All Timeframes Bullish", message = "{{ticker}}: ALL 6 timeframes (1m-D) are now BULLISH! Strong uptrend.")
alertcondition(mtfBearishAlert, title = "All Timeframes Bearish", message = "{{ticker}}: ALL 6 timeframes (1m-D) are now BEARISH! Strong downtrend.")

//---------------------------------------------------------------------------------------------------------------------}
// ADDITIONAL ALERTS
//---------------------------------------------------------------------------------------------------------------------{
// HOD/LOD alerts
hodTouch = high >= todayHigh and high[1] < todayHigh[1]
lodTouch = low <= todayLow and low[1] > todayLow[1]
alertcondition(hodTouch, title = "Price at HOD", message = "{{ticker}}: Price touched HIGH OF DAY!")
alertcondition(lodTouch, title = "Price at LOD", message = "{{ticker}}: Price touched LOW OF DAY!")

// Bias change alerts
var string prevBiasStr = na
currentBiasStr = swingTrend.bias == BULLISH ? "BULL" : "BEAR"
biasChangeToBull = not na(prevBiasStr) and prevBiasStr == "BEAR" and currentBiasStr == "BULL"
biasChangeToBear = not na(prevBiasStr) and prevBiasStr == "BULL" and currentBiasStr == "BEAR"
prevBiasStr := currentBiasStr
alertcondition(biasChangeToBull, title = "Bias Changed to BULLISH", message = "{{ticker}}: Trend changed to BULLISH!")
alertcondition(biasChangeToBear, title = "Bias Changed to BEARISH", message = "{{ticker}}: Trend changed to BEARISH!")

// Zone break alerts
supplyBreak = wasInSupply and close > supplyZoneHigh and not na(supplyZoneHigh)
demandBreak = wasInDemand and close < demandZoneLow and not na(demandZoneLow)
alertcondition(supplyBreak, title = "Supply Zone Broken", message = "{{ticker}}: Supply zone BROKEN - bullish breakout!")
alertcondition(demandBreak, title = "Demand Zone Broken", message = "{{ticker}}: Demand zone BROKEN - bearish breakdown!")

// FVG detection and alerts
bullishFvgDetected = showFairValueGapsInput and low > high[2]  // Gap up
bearishFvgDetected = showFairValueGapsInput and high < low[2]  // Gap down
alertcondition(bullishFvgDetected, title = "Bullish FVG Formed", message = "{{ticker}}: Bullish FVG (Fair Value Gap) formed! Potential support area.")
alertcondition(bearishFvgDetected, title = "Bearish FVG Formed", message = "{{ticker}}: Bearish FVG (Fair Value Gap) formed! Potential resistance area.")

// FVG fill alerts (price fills the gap)
var float bullFvgTop = na
var float bullFvgBottom = na
var float bearFvgTop = na
var float bearFvgBottom = na

if bullishFvgDetected
    bullFvgTop := low
    bullFvgBottom := high[2]
if bearishFvgDetected
    bearFvgTop := low[2]
    bearFvgBottom := high

bullFvgFilled = not na(bullFvgBottom) and low <= bullFvgBottom
bearFvgFilled = not na(bearFvgTop) and high >= bearFvgTop
alertcondition(bullFvgFilled, title = "Bullish FVG Filled", message = "{{ticker}}: Price filled a bullish FVG - potential bounce!")
alertcondition(bearFvgFilled, title = "Bearish FVG Filled", message = "{{ticker}}: Price filled a bearish FVG - potential rejection!")

// FVG rejection alerts (wick touches FVG but body rejects)
// Bullish FVG rejection = wick dips into bullish FVG but body closes above (buyers stepped in)
bullFvgRejection = not na(bullFvgBottom) and low <= bullFvgTop and low >= bullFvgBottom and close > bullFvgTop and open > bullFvgTop
// Bearish FVG rejection = wick pokes into bearish FVG but body closes below (sellers stepped in)
bearFvgRejection = not na(bearFvgTop) and high >= bearFvgBottom and high <= bearFvgTop and close < bearFvgBottom and open < bearFvgBottom
alertcondition(bullFvgRejection, title = "Bullish FVG Rejection", message = "{{ticker}}: Price REJECTED from bullish FVG! Strong buy signal.")
alertcondition(bearFvgRejection, title = "Bearish FVG Rejection", message = "{{ticker}}: Price REJECTED from bearish FVG! Strong sell signal.")

//---------------------------------------------------------------------------------------------------------------------}
// AI WEBHOOK: Send 3 closest supply and 3 closest demand zones
//---------------------------------------------------------------------------------------------------------------------{
// Type to store zone info for sorting
type zoneInfo
    float top
    float bottom
    float dist
    string strength

// Arrays to collect demand and supply zones with distances
var array<zoneInfo> demandZones = array.new<zoneInfo>()
var array<zoneInfo> supplyZones = array.new<zoneInfo>()

// Clear arrays each bar
demandZones.clear()
supplyZones.clear()

// Collect all swing zones with distances
if showSwingOrderBlocksInput and swingOrderBlocks.size() > 0
    for i = 0 to math.min(swingOrderBlocksSizeInput - 1, swingOrderBlocks.size() - 1)
        if i >= 0 and i < swingOrderBlocks.size()
            ob = swingOrderBlocks.get(i)
            
            // Calculate zone strength
            float zoneSize = ob.barHigh - ob.barLow
            int barsAgo = bar_index - ob.barIndex
            float freshnessScore = ob.retests == 0 ? 40 : ob.retests == 1 ? 20 : 0
            float sizeScore = zoneSize > atrMeasure ? 30 : zoneSize > atrMeasure * 0.5 ? 20 : 10
            float recencyScore = barsAgo < 50 ? 30 : barsAgo < 100 ? 20 : 10
            float strengthScore = freshnessScore + sizeScore + recencyScore
            string strength = strengthScore >= 70 ? "STRONG" : strengthScore >= 40 ? "MEDIUM" : "WEAK"
            
            if ob.bias == BULLISH  // Demand zone (below price)
                float dist = close - ob.barHigh
                if dist > 0  // Only zones below current price
                    demandZones.push(zoneInfo.new(ob.barHigh, ob.barLow, dist, strength))
            else  // Supply zone (above price)
                float dist = ob.barLow - close
                if dist > 0  // Only zones above current price
                    supplyZones.push(zoneInfo.new(ob.barHigh, ob.barLow, dist, strength))

// Sort by distance (closest first) - simple bubble sort for small arrays
if demandZones.size() > 1
    for i = 0 to demandZones.size() - 2
        for j = 0 to demandZones.size() - i - 2
            if demandZones.get(j).dist > demandZones.get(j + 1).dist
                zoneInfo temp = demandZones.get(j)
                demandZones.set(j, demandZones.get(j + 1))
                demandZones.set(j + 1, temp)

if supplyZones.size() > 1
    for i = 0 to supplyZones.size() - 2
        for j = 0 to supplyZones.size() - i - 2
            if supplyZones.get(j).dist > supplyZones.get(j + 1).dist
                zoneInfo temp = supplyZones.get(j)
                supplyZones.set(j, supplyZones.get(j + 1))
                supplyZones.set(j + 1, temp)

// Send SNAPSHOT every 15 minutes (for sync reliability)
var int lastSnapshotTime = 0
int currentMinute = minute(time)
bool is15MinMark = (currentMinute % 15 == 0) and (currentMinute != minute(time[1]))

if barstate.isconfirmed and is15MinMark
    // Build demand zones JSON array (top 3)
    string d1 = demandZones.size() > 0 ? str.format('{"t":{0},"b":{1},"s":"{2}"}', demandZones.get(0).top, demandZones.get(0).bottom, demandZones.get(0).strength) : ""
    string d2 = demandZones.size() > 1 ? str.format(',{"t":{0},"b":{1},"s":"{2}"}', demandZones.get(1).top, demandZones.get(1).bottom, demandZones.get(1).strength) : ""
    string d3 = demandZones.size() > 2 ? str.format(',{"t":{0},"b":{1},"s":"{2}"}', demandZones.get(2).top, demandZones.get(2).bottom, demandZones.get(2).strength) : ""
    
    // Build supply zones JSON array (top 3)
    string s1 = supplyZones.size() > 0 ? str.format('{"t":{0},"b":{1},"s":"{2}"}', supplyZones.get(0).top, supplyZones.get(0).bottom, supplyZones.get(0).strength) : ""
    string s2 = supplyZones.size() > 1 ? str.format(',{"t":{0},"b":{1},"s":"{2}"}', supplyZones.get(1).top, supplyZones.get(1).bottom, supplyZones.get(1).strength) : ""
    string s3 = supplyZones.size() > 2 ? str.format(',{"t":{0},"b":{1},"s":"{2}"}', supplyZones.get(2).top, supplyZones.get(2).bottom, supplyZones.get(2).strength) : ""
    
    string payload = str.format('{"action":"SYNC","sym":"{0}","tf":"{1}","p":{2},"d":[{3}{4}{5}],"s":[{6}{7}{8}]}',
        syminfo.ticker, timeframe.period, close, d1, d2, d3, s1, s2, s3)
    
    alert(payload, alert.freq_once_per_bar)

//---------------------------------------------------------------------------------------------------------------------}

